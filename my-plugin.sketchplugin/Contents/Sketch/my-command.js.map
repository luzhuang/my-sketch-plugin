{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/dialog/lib/index.js","webpack://exports/./node_modules/@skpm/dialog/lib/message-box.js","webpack://exports/./node_modules/@skpm/dialog/lib/open-dialog.js","webpack://exports/./node_modules/@skpm/dialog/lib/run-delegate.js","webpack://exports/./node_modules/@skpm/dialog/lib/save-dialog.js","webpack://exports/./node_modules/@skpm/fs/index.js","webpack://exports/./node_modules/@skpm/path/index.js","webpack://exports/./node_modules/cocoascript-class/lib/index.js","webpack://exports/./node_modules/cocoascript-class/lib/runtime.js","webpack://exports/./src/my-command.js","webpack://exports/external \"sketch\"","webpack://exports/external \"sketch/dom\"","webpack://exports/external \"sketch/ui\""],"names":["UI","dialog","fs","path","exportJSON","document","str","defaultExportPath","fileURL","sketchObject","String","documentName","basename","replace","rootPath","showSaveDialog","defaultPath","nameFieldLabel","buttonLabel","existsSync","confirm","showMessageBox","type","buttons","title","message","icon","NSImage","alloc","initWithContentsOfFile","context","plugin","urlForResourceNamed","rmdirSync","mkdirSync","vdPath","writeFileSync","NSWorkspace","sharedWorkspace","openFile","floor","num","Math","toJSON","data","layers","i","length","frame","name","rectX","x","rectY","y","rectWidth","width","rectHeight","height","playerX","playerY","playerPos","getSelectedDocument","page","selectedPage","JSON","stringify"],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,kBAAkB,mBAAO,CAAC,qEAAe;AACzC;AACA;;;;;;;;;;;;ACRA;AACA,kBAAkB,mBAAO,CAAC,uEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACjKA;AACA,kBAAkB,mBAAO,CAAC,uEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACzKA,gBAAgB,mBAAO,CAAC,wEAAmB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;ACzBD;AACA,kBAAkB,mBAAO,CAAC,uEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACxKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAsD;AACrF,mCAAmC,0DAA0D;AAC7F,6BAA6B,mDAAmD;AAChF,wBAAwB,eAAe;AACvC,wBAAwB,iDAAiD;AACzE,0BAA0B,gDAAgD;AAC1E,gCAAgC,sDAAsD;AACtF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW;AACX;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;AACA,WAAW;AACX;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACrhBa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,eAAe,mBAAO,CAAC,qEAAc;;AAErC;;AAEA;AACA;;AAEA,6EAA6E,YAAY;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7Da;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA,kCAAkC,qCAAqC;;AAEvE;AACA;AACA,4CAA4C,sCAAsC,GAAG,YAAY;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;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","file":"my-command.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/my-command.js\");\n","/* let's try to match the API from Electron's Dialog\n(https://github.com/electron/electron/blob/master/docs/api/dialog.md) */\n\nmodule.exports = {\n  showOpenDialog: require('./open-dialog'),\n  showSaveDialog: require('./save-dialog'),\n  showMessageBox: require('./message-box'),\n  // showErrorBox: require('./error-box'),\n}\n","/* eslint-disable no-not-accumulator-reassign/no-not-accumulator-reassign */\nvar RunDelegate = require('./run-delegate')\n\n// https://github.com/electron/electron/blob/master/docs/api/dialog.md#dialogshowmessageboxbrowserwindow-options-callback\nvar typeMap = {\n  none: 0,\n  info: 1,\n  error: 2,\n  question: 1,\n  warning: 2,\n}\nmodule.exports = function messageBox(document, options, callback) {\n  if (!document ||\n    (typeof document.class !== 'function' && !document.sketchObject)\n  ) {\n    callback = options\n    options = document\n    document = undefined\n  } else if (document.sketchObject) {\n    document = document.sketchObject\n  }\n  if (!options) {\n    options = {}\n  }\n\n  var response\n\n  var dialog = NSAlert.alloc().init()\n\n  if (options.type) {\n    dialog.alertStyle = typeMap[options.type] || 0\n  }\n\n  if (options.buttons && options.buttons.length) {\n    options.buttons.forEach(function addButton(button) {\n      dialog.addButtonWithTitle(\n        options.normalizeAccessKeys ? button.replace(/&/g, '') : button\n      )\n      // TODO: add keyboard shortcut if options.normalizeAccessKeys\n    })\n  }\n\n  if (typeof options.defaultId !== 'undefined') {\n    var buttons = dialog.buttons()\n    if (options.defaultId < buttons.length) {\n      // Focus the button at defaultId if the user opted to do so.\n      // The first button added gets set as the default selected.\n      // So remove that default, and make the requested button the default.\n      buttons[0].setKeyEquivalent('')\n      buttons[options.defaultId].setKeyEquivalent('\\r')\n    }\n  }\n\n  if (options.title) {\n    // not shown on macOS\n  }\n\n  if (options.message) {\n    dialog.messageText = options.message\n  }\n\n  if (options.detail) {\n    dialog.informativeText = options.detail\n  }\n\n  if (options.checkboxLabel) {\n    dialog.showsSuppressionButton = true\n    dialog.suppressionButton().title = options.checkboxLabel\n\n    if (typeof options.checkboxChecked !== 'undefined') {\n      dialog.suppressionButton().state = options.checkboxChecked ?\n        NSOnState :\n        NSOffState\n    }\n  }\n\n  if (options.icon) {\n    if (typeof options.icon === 'string') {\n      options.icon = NSImage.alloc().initWithContentsOfFile(options.icon)\n    }\n    dialog.icon = options.icon\n  } else if (\n    typeof __command !== 'undefined' &&\n    __command.pluginBundle() &&\n    __command.pluginBundle().icon()\n  ) {\n    dialog.icon = __command.pluginBundle().icon()\n  } else {\n    var icon = NSImage.imageNamed('plugins')\n    if (icon) {\n      dialog.icon = icon\n    }\n  }\n\n  if (!document) {\n    response = Number(dialog.runModal()) - 1000\n    if (callback) {\n      var checkboxChecked = false\n      if (options.checkboxLabel) {\n        checkboxChecked = dialog.suppressionButton().state() == NSOnState\n      }\n      callback({\n        response: response,\n        checkboxChecked: checkboxChecked,\n      })\n      return undefined\n    }\n    return response\n  }\n\n  var delegate = RunDelegate.new()\n\n  dialog.buttons().forEach(function hookButton(button, i) {\n    button.setTarget(delegate)\n    button.setAction(NSSelectorFromString('buttonClicked:'))\n    button.setTag(i)\n  })\n\n  var fiber\n  if (callback) {\n    if (coscript.createFiber) {\n      fiber = coscript.createFiber()\n    } else {\n      coscript.shouldKeepAround = true\n    }\n  }\n\n  delegate.options = NSDictionary.dictionaryWithDictionary({\n    onClicked: function handleEnd(returnCode) {\n      if (callback) {\n        callback({\n          response: Number(returnCode),\n          checkboxChecked: dialog.suppressionButton().state() == NSOnState,\n        })\n        NSApp.endSheet(dialog.window())\n        if (fiber) {\n          fiber.cleanup()\n        } else {\n          coscript.shouldKeepAround = false\n        }\n      } else {\n        NSApp.stopModalWithCode(Number(returnCode))\n      }\n    },\n  })\n\n  var window = (document.sketchObject || document).documentWindow()\n  dialog.beginSheetModalForWindow_modalDelegate_didEndSelector_contextInfo(\n    window,\n    null,\n    null,\n    null\n  )\n\n  if (!callback) {\n    response = Number(NSApp.runModalForWindow(window))\n    NSApp.endSheet(dialog.window())\n    return response\n  }\n\n  return undefined\n}\n","/* eslint-disable no-not-accumulator-reassign/no-not-accumulator-reassign */\nvar RunDelegate = require('./run-delegate')\n\n// https://github.com/electron/electron/blob/master/docs/api/dialog.md#dialogshowopendialogbrowserwindow-options-callback\nmodule.exports = function openDialog(document, options, callback) {\n  if (!document || typeof document.class !== 'function') {\n    callback = options\n    options = document\n    document = undefined\n  }\n  if (!options) {\n    options = {}\n  }\n\n  var dialog = NSOpenPanel.openPanel()\n\n  if (options.title) {\n    dialog.title = options.title\n  }\n\n  if (options.defaultPath) {\n    dialog.directoryURL = NSURL.URLWithString(options.defaultPath)\n  }\n\n  if (options.buttonLabel) {\n    dialog.prompt = options.buttonLabel\n  }\n\n  if (options.filters && options.filters.length) {\n    var exts = []\n    options.filters.forEach(function setFilter(filter) {\n      filter.extensions.forEach(function setExtension(ext) {\n        exts.push(ext)\n      })\n    })\n\n    dialog.allowedFileTypes = exts\n  }\n\n  if (options.properties && options.properties.length) {\n    options.properties.forEach(function setProperty(p) {\n      if (p === 'openFile') {\n        dialog.canChooseFiles = true\n      } else if (p === 'openDirectory') {\n        dialog.canChooseDirectories = true\n      } else if (p === 'multiSelections') {\n        dialog.allowsMultipleSelection = true\n      } else if (p === 'showHiddenFiles') {\n        dialog.showsHiddenFiles = true\n      } else if (p === 'createDirectory') {\n        dialog.createDirectory = true\n      } else if (p === 'noResolveAliases') {\n        dialog.resolvesAliases = false\n      } else if (p === 'treatPackageAsDirectory') {\n        dialog.treatsFilePackagesAsDirectories = true\n      }\n    })\n  }\n\n  if (options.message) {\n    dialog.message = options.message\n  }\n\n  var buttonClicked\n\n  function getURLs() {\n    var result = []\n    var urls = dialog.URLs()\n    for (var k = 0; k < urls.length; k += 1) {\n      result.push(String(urls[k].path()))\n    }\n\n    return result\n  }\n\n  if (!document) {\n    buttonClicked = dialog.runModal()\n    if (buttonClicked == NSOKButton) {\n      if (callback) {\n        callback(getURLs())\n        return undefined\n      }\n      return getURLs()\n    }\n\n    return []\n  }\n\n  var nsButtonClass = NSButton.class()\n\n  function findButtonWithTitleInView(title, view) {\n    if (!view || !view.subviews || !view.subviews()) {\n      return undefined\n    }\n    var subviews = view.subviews()\n    for (var i = 0; i < subviews.length; i += 1) {\n      var subview = subviews[i]\n      if (\n        subview.isKindOfClass(nsButtonClass) &&\n        String(subview.title()) == title\n      ) {\n        return subview\n      }\n      var foundButton = findButtonWithTitleInView(title, subview)\n      if (foundButton) {\n        return foundButton\n      }\n    }\n    return undefined\n  }\n\n  var cancelButton = findButtonWithTitleInView('Cancel', dialog.contentView())\n  var okButton = findButtonWithTitleInView(\n    options.buttonLabel || 'Open',\n    dialog.contentView()\n  )\n\n  var delegate = RunDelegate.new()\n\n  cancelButton.setTarget(delegate)\n  cancelButton.setAction(NSSelectorFromString('button1Clicked:'))\n  okButton.setTarget(delegate)\n  okButton.setAction(NSSelectorFromString('button0Clicked:'))\n\n  var fiber\n  if (callback) {\n    if (coscript.createFiber) {\n      fiber = coscript.createFiber()\n    } else {\n      coscript.shouldKeepAround = true\n    }\n  }\n\n  delegate.options = NSDictionary.dictionaryWithDictionary({\n    onClicked: function handleEnd(returnCode) {\n      if (callback) {\n        callback(returnCode == 0 ? getURLs() : undefined)\n        NSApp.endSheet(dialog)\n        if (fiber) {\n          fiber.cleanup()\n        } else {\n          coscript.shouldKeepAround = false\n        }\n      } else {\n        NSApp.stopModalWithCode(returnCode)\n      }\n    },\n  })\n\n  var window = (document.sketchObject || document).documentWindow()\n  dialog.beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo(\n    null,\n    null,\n    window,\n    null,\n    null,\n    null\n  )\n\n  if (!callback) {\n    buttonClicked = NSApp.runModalForWindow(window)\n    NSApp.endSheet(dialog)\n    if (buttonClicked == 0) {\n      return getURLs()\n    }\n    return undefined\n  }\n\n  return undefined\n}\n","var ObjCClass = require('cocoascript-class').default\n\nmodule.exports = new ObjCClass({\n  options: null,\n\n  'buttonClicked:': function handleButtonClicked(sender) {\n    if (this.options.onClicked) {\n      this.options.onClicked(sender.tag())\n    }\n    this.release()\n  },\n\n  'button0Clicked:': function handleButtonClicked() {\n    if (this.options.onClicked) {\n      this.options.onClicked(0)\n    }\n    this.release()\n  },\n\n  'button1Clicked:': function handleButtonClicked() {\n    if (this.options.onClicked) {\n      this.options.onClicked(1)\n    }\n    this.release()\n  },\n})\n","/* eslint-disable no-not-accumulator-reassign/no-not-accumulator-reassign */\nvar RunDelegate = require('./run-delegate')\n\n// https://github.com/electron/electron/blob/master/docs/api/dialog.md#dialogshowsavedialogbrowserwindow-options-callback\nmodule.exports = function saveDialog(document, options, callback) {\n  if (!document || typeof document.class !== 'function') {\n    callback = options\n    options = document\n    document = undefined\n  }\n  if (!options) {\n    options = {}\n  }\n\n  var buttonClicked\n  var url\n\n  var dialog = NSSavePanel.savePanel()\n\n  if (options.title) {\n    dialog.title = options.title\n  }\n\n  if (options.defaultPath) {\n    if (\n      options.defaultPath[0] === '.' ||\n      options.defaultPath[0] === '~' ||\n      options.defaultPath[0] === '/'\n    ) {\n      // that's a path\n      dialog.setDirectoryURL(\n        NSURL.URLWithString(\n          NSString.stringWithString(\n            options.defaultPath\n          ).stringByExpandingTildeInPath()\n        )\n      )\n      var parts = options.defaultPath.split('/')\n      if (parts.length > 1 && parts[parts.length - 1]) {\n        dialog.setNameFieldStringValue(parts[parts.length - 1])\n      }\n    } else {\n      dialog.setNameFieldStringValue(options.defaultPath)\n    }\n  }\n\n  if (options.buttonLabel) {\n    dialog.prompt = options.buttonLabel\n  }\n\n  if (options.filters && options.filters.length) {\n    var exts = []\n    options.filters.forEach(function setFilter(filter) {\n      filter.extensions.forEach(function setExtension(ext) {\n        exts.push(ext)\n      })\n    })\n\n    dialog.allowedFileTypes = exts\n  }\n\n  if (options.message) {\n    dialog.message = options.message\n  }\n\n  if (options.nameFieldLabel) {\n    dialog.nameFieldLabel = options.nameFieldLabel\n  }\n\n  if (options.showsTagField) {\n    dialog.showsTagField = options.showsTagField\n  }\n\n  if (!document) {\n    buttonClicked = dialog.runModal()\n    if (buttonClicked == NSOKButton) {\n      url = String(dialog.URL().path())\n\n      if (callback) {\n        callback(url)\n        return undefined\n      }\n      return url\n    }\n    return undefined\n  }\n\n  var nsButtonClass = NSButton.class()\n\n  function findButtonWithTitleInView(title, view) {\n    if (!view || !view.subviews || !view.subviews()) {\n      return undefined\n    }\n    var subviews = view.subviews()\n    for (var i = 0; i < subviews.length; i += 1) {\n      var subview = subviews[i]\n      if (\n        subview.isKindOfClass(nsButtonClass) &&\n        String(subview.title()) == title\n      ) {\n        return subview\n      }\n      var foundButton = findButtonWithTitleInView(title, subview)\n      if (foundButton) {\n        return foundButton\n      }\n    }\n    return undefined\n  }\n\n  var cancelButton = findButtonWithTitleInView('Cancel', dialog.contentView())\n  var okButton = findButtonWithTitleInView(\n    options.buttonLabel || 'Save',\n    dialog.contentView()\n  )\n\n  var delegate = RunDelegate.new()\n\n  cancelButton.setTarget(delegate)\n  cancelButton.setAction(NSSelectorFromString('button1Clicked:'))\n  okButton.setTarget(delegate)\n  okButton.setAction(NSSelectorFromString('button0Clicked:'))\n\n  var fiber\n  if (callback) {\n    if (coscript.createFiber) {\n      fiber = coscript.createFiber()\n    } else {\n      coscript.shouldKeepAround = true\n    }\n  }\n\n  delegate.options = NSDictionary.dictionaryWithDictionary({\n    onClicked: function handleEnd(returnCode) {\n      if (callback) {\n        callback(returnCode == 0 ? String(dialog.URL().path()) : undefined)\n        NSApp.endSheet(dialog)\n        if (fiber) {\n          fiber.cleanup()\n        } else {\n          coscript.shouldKeepAround = false\n        }\n      } else {\n        NSApp.stopModalWithCode(returnCode)\n      }\n    },\n  })\n\n  var window = (document.sketchObject || document).documentWindow()\n  dialog.beginSheetForDirectory_file_modalForWindow_modalDelegate_didEndSelector_contextInfo(\n    null,\n    null,\n    window,\n    null,\n    null,\n    null\n  )\n\n  if (!callback) {\n    buttonClicked = NSApp.runModalForWindow(window)\n    NSApp.endSheet(dialog)\n    if (buttonClicked == 0) {\n      return String(dialog.URL().path())\n    }\n    return undefined\n  }\n\n  return undefined\n}\n","// TODO: async. Should probably be done with NSFileHandle and some notifications\n// TODO: file descriptor. Needs to be done with NSFileHandle\n\nmodule.exports.constants = {\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1\n}\n\nmodule.exports.accessSync = function(path, mode) {\n  mode = mode | 0\n  var fileManager = NSFileManager.defaultManager()\n\n  switch (mode) {\n    case 0:\n      return module.exports.existsSync(path)\n    case 1:\n      return Boolean(fileManager.isExecutableFileAtPath(path))\n    case 2:\n      return Boolean(fileManager.isWritableFileAtPath(path))\n    case 3:\n      return Boolean(fileManager.isExecutableFileAtPath(path) && fileManager.isWritableFileAtPath(path))\n    case 4:\n      return Boolean(fileManager.isReadableFileAtPath(path))\n    case 5:\n      return Boolean(fileManager.isReadableFileAtPath(path) && fileManager.isExecutableFileAtPath(path))\n    case 6:\n      return Boolean(fileManager.isReadableFileAtPath(path) && fileManager.isWritableFileAtPath(path))\n    case 7:\n      return Boolean(fileManager.isReadableFileAtPath(path) && fileManager.isWritableFileAtPath(path) && fileManager.isExecutableFileAtPath(path))\n  }\n}\n\nmodule.exports.appendFileSync = function(file, data, options) {\n  if (!module.exports.existsSync(file)) {\n    return module.exports.writeFileSync(file, data, options)\n  }\n\n  var handle = NSFileHandle.fileHandleForWritingAtPath(file)\n  handle.seekToEndOfFile()\n\n  if (data && data.mocha && data.mocha().class() === 'NSData') {\n    handle.writeData(data)\n    return\n  }\n\n  var encoding = options && options.encoding ? options.encoding : (options ? options : 'utf8')\n\n  var string = NSString.stringWithString(data)\n  var nsdata\n\n  switch (encoding) {\n    case 'utf8':\n      nsdata = string.dataUsingEncoding(NSUTF8StringEncoding)\n      break\n    case 'ascii':\n      nsdata = string.dataUsingEncoding(NSASCIIStringEncoding)\n      break\n    case 'utf16le':\n    case 'ucs2':\n      nsdata = string.dataUsingEncoding(NSUTF16LittleEndianStringEncoding)\n      break\n    case 'base64':\n      var plainData = string.dataUsingEncoding(NSUTF8StringEncoding)\n      nsdata = plainData.base64EncodedStringWithOptions(0).dataUsingEncoding(NSUTF8StringEncoding)\n      break\n    case 'latin1':\n    case 'binary':\n      nsdata = string.dataUsingEncoding(NSISOLatin1StringEncoding)\n      break\n    case 'hex':\n      // TODO: how?\n    default:\n      nsdata = string.dataUsingEncoding(NSUTF8StringEncoding)\n      break\n  }\n\n  handle.writeData(data)\n}\n\nmodule.exports.chmodSync = function(path, mode) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.setAttributes_ofItemAtPath_error({\n    NSFilePosixPermissions: mode\n  }, path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.copyFileSync = function(path, dest, flags) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.copyItemAtPath_toPath_error(path, dest, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.existsSync = function(path) {\n  var fileManager = NSFileManager.defaultManager()\n  return Boolean(fileManager.fileExistsAtPath(path))\n}\n\nmodule.exports.linkSync = function(existingPath, newPath) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.linkItemAtPath_toPath_error(existingPath, newPath, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.mkdirSync = function(path, mode) {\n  mode = mode || 0o777\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(path, false, {\n    NSFilePosixPermissions: mode\n  }, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.mkdtempSync = function(path) {\n  function makeid() {\n    var text = \"\";\n    var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (var i = 0; i < 6; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n  var tempPath = path + makeid()\n  module.exports.mkdirSync(tempPath)\n  return tempPath\n}\n\nmodule.exports.readdirSync = function(path) {\n  var fileManager = NSFileManager.defaultManager()\n  var paths = fileManager.subpathsAtPath(path)\n  var arr = []\n  for (var i = 0; i < paths.length; i++) {\n    arr.push(paths[i])\n  }\n  return arr\n}\n\nmodule.exports.readFileSync = function(path, options) {\n  var encoding = options && options.encoding ? options.encoding : (options ? options : 'buffer')\n  var fileManager = NSFileManager.defaultManager()\n  var data = fileManager.contentsAtPath(path)\n  switch (encoding) {\n    case 'utf8':\n      return String(NSString.alloc().initWithData_encoding(data, NSUTF8StringEncoding))\n    case 'ascii':\n      return String(NSString.alloc().initWithData_encoding(data, NSASCIIStringEncoding))\n    case 'utf16le':\n    case 'ucs2':\n      return String(NSString.alloc().initWithData_encoding(data, NSUTF16LittleEndianStringEncoding))\n    case 'base64':\n      var nsdataDecoded = NSData.alloc().initWithBase64EncodedData_options(data, 0)\n      return String(NSString.alloc().initWithData_encoding(nsdataDecoded, NSUTF8StringEncoding))\n    case 'latin1':\n    case 'binary':\n      return String(NSString.alloc().initWithData_encoding(data, NSISOLatin1StringEncoding))\n    case 'hex':\n      // TODO: how?\n      return data\n    default:\n      return data\n  }\n}\n\nmodule.exports.readlinkSync = function(path) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  var result = fileManager.destinationOfSymbolicLinkAtPath_error(path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n\n  return result\n}\n\nmodule.exports.realpathSync = function(path) {\n  return NSString.stringByResolvingSymlinksInPath(path)\n}\n\nmodule.exports.renameSync = function(oldPath, newPath) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.moveItemAtPath_toPath_error(oldPath, newPath, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.rmdirSync = function(path) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  fileManager.removeItemAtPath_error(path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.statSync = function(path) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  var result = fileManager.attributesOfItemAtPath_error(path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n\n  return {\n    dev: String(result.NSFileDeviceIdentifier),\n    // ino: 48064969, The file system specific \"Inode\" number for the file.\n    mode: result.NSFileType | result.NSFilePosixPermissions,\n    nlink: Number(result.NSFileReferenceCount),\n    uid: String(result.NSFileOwnerAccountID),\n    gid: String(result.NSFileGroupOwnerAccountID),\n    // rdev: 0, A numeric device identifier if the file is considered \"special\".\n    size: Number(result.NSFileSize),\n    // blksize: 4096, The file system block size for i/o operations.\n    // blocks: 8, The number of blocks allocated for this file.\n    atimeMs: Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    mtimeMs: Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    ctimeMs: Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    birthtimeMs: Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000,\n    atime: new Date(Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5), // the 0.5 comes from the node source. Not sure why it's added but in doubt...\n    mtime: new Date(Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5),\n    ctime: new Date(Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5),\n    birthtime: new Date(Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000 + 0.5),\n    isBlockDevice: function() { return result.NSFileType === NSFileTypeBlockSpecial },\n    isCharacterDevice: function() { return result.NSFileType === NSFileTypeCharacterSpecial },\n    isDirectory: function() { return result.NSFileType === NSFileTypeDirectory },\n    isFIFO: function() { return false },\n    isFile: function() { return result.NSFileType === NSFileTypeRegular },\n    isSocket: function() { return result.NSFileType === NSFileTypeSocket },\n    isSymbolicLink: function() { return result.NSFileType === NSFileTypeSymbolicLink },\n  }\n}\n\nmodule.exports.symlinkSync = function(target, path) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  var result = fileManager.createSymbolicLinkAtPath_withDestinationPath_error(path, target, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.truncateSync = function(path, len) {\n  var hFile = NSFileHandle.fileHandleForUpdatingAtPath(sFilePath)\n  hFile.truncateFileAtOffset(len || 0)\n  hFile.closeFile()\n}\n\nmodule.exports.unlinkSync = function(path) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  var result = fileManager.removeItemAtPath_error(path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.utimesSync = function(path, aTime, mTime) {\n  var err = MOPointer.alloc().init()\n  var fileManager = NSFileManager.defaultManager()\n  var result = fileManager.setAttributes_ofItemAtPath_error({\n    NSFileModificationDate: aTime\n  }, path, err)\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n\nmodule.exports.writeFileSync = function(path, data, options) {\n  var encoding = options && options.encoding ? options.encoding : (options ? options : 'utf8')\n\n  if (data && data.mocha && data.mocha().class() === 'NSData') {\n    data.writeToFile_atomically(path, true)\n    return\n  }\n\n  var err = MOPointer.alloc().init()\n  var string = NSString.stringWithString(data)\n\n  switch (encoding) {\n    case 'utf8':\n      string.writeToFile_atomically_encoding_error(path, true, NSUTF8StringEncoding, err)\n      break\n    case 'ascii':\n      string.writeToFile_atomically_encoding_error(path, true, NSASCIIStringEncoding, err)\n      break\n    case 'utf16le':\n    case 'ucs2':\n      string.writeToFile_atomically_encoding_error(path, true, NSUTF16LittleEndianStringEncoding, err)\n      break\n    case 'base64':\n      var plainData = string.dataUsingEncoding(NSUTF8StringEncoding)\n      var nsdataEncoded = plainData.base64EncodedStringWithOptions(0)\n      nsdataEncoded.writeToFile_atomically(path, true)\n      break\n    case 'latin1':\n    case 'binary':\n      string.writeToFile_atomically_encoding_error(path, true, NSISOLatin1StringEncoding, err)\n      break\n    case 'hex':\n      // TODO: how?\n    default:\n      string.writeToFile_atomically_encoding_error(path, true, NSUTF8StringEncoding, err)\n      break\n  }\n\n  if (err.value() !== null) {\n    throw new Error(err.value())\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// we only expose the posix implementation since Sketch only runs on macOS\n\nvar CHAR_FORWARD_SLASH = 47\nvar CHAR_DOT = 46\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot) {\n  var res = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var code\n  for (var i = 0; i <= path.length; i += 1) {\n    if (i < path.length) code = path.charCodeAt(i)\n    else if (code === CHAR_FORWARD_SLASH) break\n    else code = CHAR_FORWARD_SLASH\n    if (code === CHAR_FORWARD_SLASH) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/')\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = ''\n                lastSegmentLength = 0\n              } else {\n                res = res.slice(0, lastSlashIndex)\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n              }\n              lastSlash = i\n              dots = 0\n              continue\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += '/..'\n          else res = '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)\n        else res = path.slice(lastSlash + 1, i)\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root\n  var base =\n    pathObject.base || (pathObject.name || '') + (pathObject.ext || '')\n  if (!dir) {\n    return base\n  }\n  if (dir === pathObject.root) {\n    return dir + base\n  }\n  return dir + sep + base\n}\n\nfunction normalizePath(path) {\n  if (typeof path === 'string') {\n    return path\n  }\n  if (path && path.class && typeof path.class === 'function') {\n    const className = String(path.class())\n    if (className === 'NSString') {\n      return String(path)\n    } else if (className === 'NSURL') {\n      return String(path.path())\n    }\n  }\n  throw new Error('path should be a string')\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = ''\n    var resolvedAbsolute = false\n    var cwd\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i -= 1) {\n      var path\n      if (i >= 0) path = arguments[i]\n      else {\n        if (cwd === undefined)\n          cwd = posix.dirname(String(__command.script().URL().path()) || MSPluginManager.defaultPluginURL())\n        path = cwd\n      }\n\n      path = normalizePath(path)\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue\n      }\n\n      resolvedPath = path + '/' + resolvedPath\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute)\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) return '/' + resolvedPath\n      else return '/'\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath\n    } else {\n      return '.'\n    }\n  },\n\n  normalize: function normalize(path) {\n    path = normalizePath(path)\n\n    if (path.length === 0) return '.'\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n    var trailingSeparator =\n      path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH\n\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute)\n\n    if (path.length === 0 && !isAbsolute) path = '.'\n    if (path.length > 0 && trailingSeparator) path += '/'\n\n    if (isAbsolute) return '/' + path\n    return path\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    path = normalizePath(path)\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  },\n\n  join: function join() {\n    if (arguments.length === 0) return '.'\n    var joined\n    for (var i = 0; i < arguments.length; i += 1) {\n      var arg = arguments[i]\n      arg = normalizePath(arg)\n      if (arg.length > 0) {\n        if (joined === undefined) joined = arg\n        else joined += '/' + arg\n      }\n    }\n    if (joined === undefined) return '.'\n    return posix.normalize(joined)\n  },\n\n  relative: function relative(from, to) {\n    from = normalizePath(from)\n    to = normalizePath(to)\n\n    if (from === to) return ''\n\n    from = posix.resolve(from)\n    to = posix.resolve(to)\n\n    if (from === to) return ''\n\n    // Trim any leading backslashes\n    var fromStart = 1\n    for (; fromStart < from.length; fromStart += 1) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var fromEnd = from.length\n    var fromLen = fromEnd - fromStart\n\n    // Trim any leading backslashes\n    var toStart = 1\n    for (; toStart < to.length; toStart += 1) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) break\n    }\n    var toEnd = to.length\n    var toLen = toEnd - toStart\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen\n    var lastCommonSep = -1\n    var i = 0\n    for (; i <= length; i += 1) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1)\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i)\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0\n          }\n        }\n        break\n      }\n      var fromCode = from.charCodeAt(fromStart + i)\n      var toCode = to.charCodeAt(toStart + i)\n      if (fromCode !== toCode) break\n      else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i\n    }\n\n    var out = ''\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; i += 1) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) out += '..'\n        else out += '/..'\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep)\n    else {\n      toStart += lastCommonSep\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) toStart += 1\n      return to.slice(toStart)\n    }\n  },\n\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path\n  },\n\n  dirname: function dirname(path) {\n    path = normalizePath(path)\n    if (path.length === 0) return '.'\n    var code = path.charCodeAt(0)\n    var hasRoot = code === CHAR_FORWARD_SLASH\n    var end = -1\n    var matchedSlash = true\n    for (var i = path.length - 1; i >= 1; i -= 1) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i\n          break\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.'\n    if (hasRoot && end === 1) return '//'\n    return path.slice(0, end)\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new Error('ext should be a string')\n    path = normalizePath(path)\n\n    var start = 0\n    var end = -1\n    var matchedSlash = true\n    var i\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return ''\n      var extIdx = ext.length - 1\n      var firstNonSlashEnd = -1\n      for (i = path.length - 1; i >= 0; i -= 1) {\n        var code = path.charCodeAt(i)\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false\n            firstNonSlashEnd = i + 1\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1\n              end = firstNonSlashEnd\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd\n      else if (end === -1) end = path.length\n      return path.slice(start, end)\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false\n          end = i + 1\n        }\n      }\n\n      if (end === -1) return ''\n      return path.slice(start, end)\n    }\n  },\n\n  extname: function extname(path) {\n    path = normalizePath(path)\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      return ''\n    }\n    return path.slice(startDot, end)\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new Error('pathObject should be an Object')\n    }\n    return _format('/', pathObject)\n  },\n\n  parse: function parse(path) {\n    path = normalizePath(path)\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' }\n    if (path.length === 0) return ret\n    var code = path.charCodeAt(0)\n    var isAbsolute = code === CHAR_FORWARD_SLASH\n    var start\n    if (isAbsolute) {\n      ret.root = '/'\n      start = 1\n    } else {\n      start = 0\n    }\n    var startDot = -1\n    var startPart = 0\n    var end = -1\n    var matchedSlash = true\n    var i = path.length - 1\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 ||\n      end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n    ) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end)\n        else ret.base = ret.name = path.slice(startPart, end)\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot)\n        ret.base = path.slice(1, end)\n      } else {\n        ret.name = path.slice(startPart, startDot)\n        ret.base = path.slice(startPart, end)\n      }\n      ret.ext = path.slice(startDot, end)\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1)\n    else if (isAbsolute) ret.dir = '/'\n\n    return ret\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null,\n}\n\nposix.posix = posix\n\nmodule.exports = posix\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = undefined;\nexports.default = ObjCClass;\n\nvar _runtime = require(\"./runtime.js\");\n\nexports.SuperCall = _runtime.SuperCall;\n\n// super when returnType is id and args are void\n// id objc_msgSendSuper(struct objc_super *super, SEL op, void)\n\nconst SuperInit = (0, _runtime.SuperCall)(NSStringFromSelector(\"init\"), [], { type: \"@\" });\n\n// Returns a real ObjC class. No need to use new.\nfunction ObjCClass(defn) {\n  const superclass = defn.superclass || NSObject;\n  const className = (defn.className || defn.classname || \"ObjCClass\") + NSUUID.UUID().UUIDString();\n  const reserved = new Set(['className', 'classname', 'superclass']);\n  var cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, superclass);\n  // Add each handler to the class description\n  const ivars = [];\n  for (var key in defn) {\n    const v = defn[key];\n    if (typeof v == 'function' && key !== 'init') {\n      var selector = NSSelectorFromString(key);\n      cls.addInstanceMethodWithSelector_function_(selector, v);\n    } else if (!reserved.has(key)) {\n      ivars.push(key);\n      cls.addInstanceVariableWithName_typeEncoding(key, \"@\");\n    }\n  }\n\n  cls.addInstanceMethodWithSelector_function_(NSSelectorFromString('init'), function () {\n    const self = SuperInit.call(this);\n    ivars.map(name => {\n      Object.defineProperty(self, name, {\n        get() {\n          return getIvar(self, name);\n        },\n        set(v) {\n          (0, _runtime.object_setInstanceVariable)(self, name, v);\n        }\n      });\n      self[name] = defn[name];\n    });\n    // If there is a passsed-in init funciton, call it now.\n    if (typeof defn.init == 'function') defn.init.call(this);\n    return self;\n  });\n\n  return cls.registerClass();\n};\n\nfunction getIvar(obj, name) {\n  const retPtr = MOPointer.new();\n  (0, _runtime.object_getInstanceVariable)(obj, name, retPtr);\n  return retPtr.value().retain().autorelease();\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = SuperCall;\nexports.CFunc = CFunc;\nconst objc_super_typeEncoding = '{objc_super=\"receiver\"@\"super_class\"#}';\n\n// You can store this to call your function. this must be bound to the current instance.\nfunction SuperCall(selector, argTypes, returnType) {\n  const func = CFunc(\"objc_msgSendSuper\", [{ type: '^' + objc_super_typeEncoding }, { type: \":\" }, ...argTypes], returnType);\n  return function (...args) {\n    const struct = make_objc_super(this, this.superclass());\n    const structPtr = MOPointer.alloc().initWithValue_(struct);\n    return func(structPtr, selector, ...args);\n  };\n}\n\n// Recursively create a MOStruct\nfunction makeStruct(def) {\n  if (typeof def !== 'object' || Object.keys(def).length == 0) {\n    return def;\n  }\n  const name = Object.keys(def)[0];\n  const values = def[name];\n\n  const structure = MOStruct.structureWithName_memberNames_runtime(name, Object.keys(values), Mocha.sharedRuntime());\n\n  Object.keys(values).map(member => {\n    structure[member] = makeStruct(values[member]);\n  });\n\n  return structure;\n}\n\nfunction make_objc_super(self, cls) {\n  return makeStruct({\n    objc_super: {\n      receiver: self,\n      super_class: cls\n    }\n  });\n}\n\n// Due to particularities of the JS bridge, we can't call into MOBridgeSupport objects directly\n// But, we can ask key value coding to do the dirty work for us ;)\nfunction setKeys(o, d) {\n  const funcDict = NSMutableDictionary.dictionary();\n  funcDict.o = o;\n  Object.keys(d).map(k => funcDict.setValue_forKeyPath(d[k], \"o.\" + k));\n}\n\n// Use any C function, not just ones with BridgeSupport\nfunction CFunc(name, args, retVal) {\n  function makeArgument(a) {\n    if (!a) return null;\n    const arg = MOBridgeSupportArgument.alloc().init();\n    setKeys(arg, {\n      type64: a.type\n    });\n    return arg;\n  }\n  const func = MOBridgeSupportFunction.alloc().init();\n  setKeys(func, {\n    name: name,\n    arguments: args.map(makeArgument),\n    returnValue: makeArgument(retVal)\n  });\n  return func;\n}\n\n/*\n@encode(char*) = \"*\"\n@encode(id) = \"@\"\n@encode(Class) = \"#\"\n@encode(void*) = \"^v\"\n@encode(CGRect) = \"{CGRect={CGPoint=dd}{CGSize=dd}}\"\n@encode(SEL) = \":\"\n*/\n\nfunction addStructToBridgeSupport(key, structDef) {\n  // OK, so this is probably the nastiest hack in this file.\n  // We go modify MOBridgeSupportController behind its back and use kvc to add our own definition\n  // There isn't another API for this though. So the only other way would be to make a real bridgesupport file.\n  const symbols = MOBridgeSupportController.sharedController().valueForKey('symbols');\n  if (!symbols) throw Error(\"Something has changed within bridge support so we can't add our definitions\");\n  // If someone already added this definition, don't re-register it.\n  if (symbols[key] !== null) return;\n  const def = MOBridgeSupportStruct.alloc().init();\n  setKeys(def, {\n    name: key,\n    type: structDef.type\n  });\n  symbols[key] = def;\n};\n\n// This assumes the ivar is an object type. Return value is pretty useless.\nconst object_getInstanceVariable = exports.object_getInstanceVariable = CFunc(\"object_getInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"^@\" }], { type: \"^{objc_ivar=}\" });\n// Again, ivar is of object type\nconst object_setInstanceVariable = exports.object_setInstanceVariable = CFunc(\"object_setInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"@\" }], { type: \"^{objc_ivar=}\" });\n\n// We need Mocha to understand what an objc_super is so we can use it as a function argument\naddStructToBridgeSupport('objc_super', { type: objc_super_typeEncoding });","import sketch from 'sketch'\nconst UI = require('sketch/ui');\nconst dialog = require('@skpm/dialog');\nconst fs = require('@skpm/fs');\nconst path = require('@skpm/path');\n// documentation: https://developer.sketchapp.com/reference/api/\n\nfunction exportJSON(document, str) {\n  // Ask user to pick a file, with a default export name pre-filled.\n  let defaultExportPath = 'sketch2vd';\n  // TODO: figure out why document.sketbhObject is undefined... it shouldn't be?\n  let fileURL = document.sketchObject ? document.sketchObject.fileURL() : '';\n  if (fileURL) {\n    fileURL = String(fileURL.path());\n    const documentName = path.basename(fileURL).replace(/\\.[^.]+$/, ''); // Strip extension.\n    defaultExportPath = `${documentName}`;\n  }\n\n  const rootPath = dialog.showSaveDialog({\n    defaultPath: defaultExportPath,\n    nameFieldLabel: 'Export directory name:',\n    buttonLabel: 'Export',\n  });\n\n  if (!rootPath) {\n    return;\n  }\n\n  // Confirm overwrite.\n  if (fs.existsSync(rootPath)) {\n    let confirm =\n      0 ===\n      dialog.showMessageBox(document.sketchObject, {\n        type: 'question',\n        buttons: ['Overwrite', 'Cancel'],\n        title: 'Directory exists, overwrite?',\n        message:\n          'The output directory you chose already exists. Are you sure you want to overwrite it?\\n\\n' +\n          rootPath,\n        icon: NSImage.alloc().initWithContentsOfFile(\n          // TODO: replace icon.png with our own custom one\n          context.plugin.urlForResourceNamed('icon.png').path()\n        ),\n      });\n    if (!confirm) {\n      return;\n    }\n    // TODO: this doesn't delete the directory if it is non-empty... fix?\n    fs.rmdirSync(rootPath);\n  }\n  fs.mkdirSync(rootPath);\n\n  const vdPath = `${rootPath}/data.json`;\n  fs.writeFileSync(vdPath, str);\n  NSWorkspace.sharedWorkspace().openFile(vdPath);\n  UI.message(' Exported!');\n}\n\nfunction floor(num) {\n  return Math.floor(num * 100) / 100\n}\nfunction toJSON(data, layers) {\n  for (let i = 0; i < layers.length; ++i) {\n    if (layers[i].layers && layers[i].layers.length) {\n      toJSON(data, layers[i].layers)\n    }\n    let frame = layers[i].frame\n    data[layers[i].name] = data[layers[i].name] || {}\n    let rectX = floor(frame.x)\n    let rectY = floor(frame.y)\n    let rectWidth = floor(frame.width)\n    let rectHeight = floor(frame.height)\n    data[layers[i].name].frame = [rectX, rectY, rectWidth, rectHeight]\n    let playerX = floor(rectX + (rectWidth - 100) / 2)\n    let playerY = floor(rectY + (rectHeight - 100) / 2)\n    data[layers[i].name].playerPos = [playerX, playerY]\n  }\n\n}\nexport default function() {\n  let document = require('sketch/dom').getSelectedDocument()\n  if (document) {\n    let page = document.selectedPage\n    let layers = page.layers\n    let data = {}\n    toJSON(data, layers)\n   exportJSON(document, JSON.stringify(data))\n  }\n}\n","module.exports = require(\"sketch\");","module.exports = require(\"sketch/dom\");","module.exports = require(\"sketch/ui\");"],"sourceRoot":""}